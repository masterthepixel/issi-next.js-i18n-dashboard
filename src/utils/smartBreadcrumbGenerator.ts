/**
 * Smart Breadcrumb Generator
 * Generates breadcrumb data with automatic fallbacks for missing translations
 */

import { AutoTranslationSystem } from './autoTranslation';
import { getPathSegments } from './breadcrumbUtils';

export interface BreadcrumbItem {
  label: string;
  href: string;
  translationKey: string;
  isActive: boolean;
  isAutoGenerated?: boolean;
}

export interface PageSEOData {
  title: string;
  description: string;
  keywords: string;
  canonical: string;
}

export interface BreadcrumbStructuredData {
  "@context": string;
  "@type": string;
  "inLanguage": string;
  "itemListElement": Array<{
    "@type": string;
    "position": number;
    "name": string;
    "item"?: string;
  }>;
}

interface RouteConfig {
  translationKey: string;
  titleKey: string;
  descriptionKey: string;
  keywordsKey: string;
  href: string;
  fallbacks?: {
    title: string;
    description: string;
    keywords: string;
  };
}

export class SmartBreadcrumbGenerator {
  private lang: string;
  private pathname: string;
  private messages: any;
  private baseUrl: string;

  constructor(lang: string, pathname: string, messages: any, baseUrl = 'https://issi.com') {
    this.lang = lang;
    this.pathname = pathname;
    this.messages = messages;
    this.baseUrl = baseUrl;
  }

  /**
   * Static route configuration for known pages
   */
  private static routeConfig: Record<string, Omit<RouteConfig, 'fallbacks'>> = {
    'services': {
      translationKey: 'nav.services',
      titleKey: 'pages.services.title',
      descriptionKey: 'pages.services.seo.description',
      keywordsKey: 'pages.services.seo.keywords',
      href: '/services'
    },
    'products': {
      translationKey: 'nav.products',
      titleKey: 'pages.products.title', 
      descriptionKey: 'pages.products.seo.description',
      keywordsKey: 'pages.products.seo.keywords',
      href: '/products'
    },
    'government': {
      translationKey: 'nav.government',
      titleKey: 'pages.government.title',
      descriptionKey: 'pages.government.seo.description', 
      keywordsKey: 'pages.government.seo.keywords',
      href: '/government'
    },
    'elearning': {
      translationKey: 'nav.eLearning',
      titleKey: 'pages.elearning.title',
      descriptionKey: 'pages.elearning.seo.description',
      keywordsKey: 'pages.elearning.seo.keywords', 
      href: '/elearning'
    },
    'compliance': {
      translationKey: 'nav.compliance',
      titleKey: 'pages.compliance.title',
      descriptionKey: 'pages.compliance.seo.description',
      keywordsKey: 'pages.compliance.seo.keywords',
      href: '/compliance'
    },
    'about': {
      translationKey: 'nav.about',
      titleKey: 'pages.about.title',
      descriptionKey: 'pages.about.seo.description',
      keywordsKey: 'pages.about.seo.keywords',
      href: '/about'
    },
    'contact': {
      translationKey: 'nav.contact', 
      titleKey: 'pages.contact.title',
      descriptionKey: 'pages.contact.seo.description',
      keywordsKey: 'pages.contact.seo.keywords',
      href: '/contact'
    },
    'terms': {
      translationKey: 'footer.terms',
      titleKey: 'pages.terms.title',
      descriptionKey: 'pages.terms.seo.description',
      keywordsKey: 'pages.terms.seo.keywords', 
      href: '/terms'
    },
    'privacy': {
      translationKey: 'footer.privacy',
      titleKey: 'pages.privacy.title',
      descriptionKey: 'pages.privacy.seo.description',
      keywordsKey: 'pages.privacy.seo.keywords',
      href: '/privacy'
    }
  };

  /**
   * Gets route configuration for a segment, with automatic generation for unknown routes
   */
  private getRouteConfig(segment: string): RouteConfig {
    // Return static config if exists
    const staticConfig = SmartBreadcrumbGenerator.routeConfig[segment];
    if (staticConfig) {
      return staticConfig as RouteConfig;
    }

    // Generate dynamic config for new pages
    return this.generateDynamicConfig(segment);
  }

  /**
   * Generates dynamic configuration for unknown routes
   */
  private generateDynamicConfig(segment: string): RouteConfig {
    // Convert URL segment to readable title
    const autoTitle = AutoTranslationSystem.getAutoTranslation(segment, this.lang);
    const autoSEO = AutoTranslationSystem.generateAutoSEO(segment, this.lang);
    
    // Check if translations exist, fallback to auto-generated
    const translationKey = `nav.${segment}`;
    const titleKey = `pages.${segment}.title`;
    const descriptionKey = `pages.${segment}.seo.description`;
    
    return {
      translationKey,
      titleKey,
      descriptionKey,
      keywordsKey: `pages.${segment}.seo.keywords`,
      href: `/${segment}`,
      fallbacks: {
        title: autoTitle,
        description: autoSEO.description,
        keywords: autoSEO.keywords
      }
    };
  }

  /**
   * Safely gets translation value with fallback
   */
  private getTranslation(key: string, fallback?: string): string {
    // Try to access nested keys (e.g., "pages.services.title")
    const keys = key.split('.');
    let value = this.messages;
    
    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k];
      } else {
        return fallback || key;
      }
    }
    
    return typeof value === 'string' ? value : (fallback || key);
  }

  /**
   * Generates breadcrumb items with full i18n support and auto-generation
   */
  generateBreadcrumbItems(): BreadcrumbItem[] {
    const segments = getPathSegments(this.pathname, this.lang);
    const items: BreadcrumbItem[] = [];

    // Always start with Home
    items.push({
      label: this.getTranslation('nav.home', 'Home'),
      href: `/${this.lang}`,
      translationKey: 'nav.home',
      isActive: false,
      isAutoGenerated: false
    });

    // Build breadcrumb path
    let currentPath = '';
    segments.forEach((segment, index) => {
      currentPath += `/${segment}`;
      const isLast = index === segments.length - 1;
      const config = this.getRouteConfig(segment);

      // Try to get translated title, fallback to auto-generated
      let label = this.getTranslation(config.translationKey) || 
                  this.getTranslation(config.titleKey);
      
      let isAutoGenerated = false;
      
      // If no translation found, use fallback or auto-generate
      if (label === config.translationKey || label === config.titleKey) {
        if (config.fallbacks?.title) {
          label = config.fallbacks.title;
          isAutoGenerated = true;
        } else {
          label = AutoTranslationSystem.getAutoTranslation(segment, this.lang);
          isAutoGenerated = true;
        }
      }

      items.push({
        label,
        href: isLast ? '' : `/${this.lang}${currentPath}`,
        translationKey: config.translationKey,
        isActive: isLast,
        isAutoGenerated
      });
    });

    return items;
  }

  /**
   * Generates SEO metadata for current page
   */
  generateSEOData(): PageSEOData {
    const segments = getPathSegments(this.pathname, this.lang);
    
    if (segments.length === 0) {
      return {
        title: this.getTranslation('nav.home', 'Home'),
        description: this.getTranslation('pages.home.seo.description', ''),
        keywords: this.getTranslation('pages.home.seo.keywords', ''),
        canonical: `${this.baseUrl}/${this.lang}`
      };
    }

    const currentSegment = segments[segments.length - 1];
    const config = this.getRouteConfig(currentSegment);

    // Try to get translated SEO data
    let title = this.getTranslation(config.titleKey);
    let description = this.getTranslation(config.descriptionKey);
    let keywords = this.getTranslation(config.keywordsKey);

    // Use fallbacks if translations don't exist
    if (title === config.titleKey && config.fallbacks) {
      title = config.fallbacks.title;
    }
    if (description === config.descriptionKey && config.fallbacks) {
      description = config.fallbacks.description;
    }
    if (keywords === config.keywordsKey && config.fallbacks) {
      keywords = config.fallbacks.keywords;
    }

    // Last resort: auto-generate
    if (title === config.titleKey) {
      title = AutoTranslationSystem.getAutoTranslation(currentSegment, this.lang);
    }
    if (description === config.descriptionKey) {
      const autoSEO = AutoTranslationSystem.generateAutoSEO(currentSegment, this.lang);
      description = autoSEO.description;
      keywords = autoSEO.keywords;
    }

    return {
      title,
      description,
      keywords,
      canonical: `${this.baseUrl}/${this.lang}${this.pathname.replace(`/${this.lang}`, '')}`
    };
  }

  /**
   * Generates JSON-LD structured data for breadcrumbs
   */
  generateStructuredData(): BreadcrumbStructuredData {
    const items = this.generateBreadcrumbItems();
    
    return {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList", 
      "inLanguage": this.lang,
      "itemListElement": items.map((item, index) => ({
        "@type": "ListItem",
        "position": index + 1,
        "name": item.label,
        ...(item.href && { "item": `${this.baseUrl}${item.href}` })
      }))
    };
  }

  /**
   * Adds new static route configurations
   */
  static addRouteConfig(segment: string, config: Omit<RouteConfig, 'fallbacks'>): void {
    SmartBreadcrumbGenerator.routeConfig[segment] = config;
  }

  /**
   * Gets all static route configurations (for debugging)
   */
  static getRouteConfigs(): Record<string, Omit<RouteConfig, 'fallbacks'>> {
    return { ...SmartBreadcrumbGenerator.routeConfig };
  }
}
